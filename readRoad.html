<html>
  <head>
    <style>
      #log {
          height: 100px;
          width: 130px;
          float: right;
      }
      #controls {
          height: 200px;
          width: 100px;
          float: right;
      }
  </style>
    <script src='osmtogeojson.js'></script>
    <!-- <script src="https://pixijs.download/release/pixi.min.js"></script> -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
    <script src="mapReader.js"></script>
    <script src="car.js"></script>
    <script src="curveRoads.js"></script>
    <script src="inter.js"></script>
  </head>
  <body>
    <script>
        const WIDTH = 640; 
        const HEIGHT = 380;
        const HOR_ROAD = 1; 
        const VER_ROAD = 1;
        const CARS = 4;
        const MAX_CARS = 10;
        const ROAD_SIZE = 20;
        const CAR_SIZE = 8;

        let cars = [];
        let startPs = [];
        let roads = [];
        let water = false;
        let house = false; 
        let sizeRoad = 6;

        let files = [];
        files[0] = "maps/buxtonOverlook.xml";
        files[1] = "maps/mapleStreet.xml";
        files[2] = "maps/northStreet.xml";
        files[3] = "maps/DunstanInters.xml";
        files[4] = "maps/threeInterRouteOne.xml";
        let file = "maps/northStreet.xml";

        function genMap( id ){
          var xhttp = new XMLHttpRequest();
          xhttp.onreadystatechange = function() {
              if (this.readyState == 4 && this.status == 200) {
                makeMap(this);
              }
          };
          xhttp.open("GET", files[id], true);
          xhttp.send();
        }


        function makeMap(xml) {
          let bounds = [];
          for (let i = 0; i < 4; i++) {
            bounds.push(xml.responseXML.all[1].attributes[i].nodeValue);
          }

          let mapSys = new coords(bounds);
          let width = mapSys.get_width();
          let height = mapSys.get_height();
          const app = new PIXI.Application({ background: '#87CEFA', width: width, height: height });

          let roadPs = [];
          let running = true; 
          let current_car = 1; 
          let pause_car = 40;
          let car_pause = 0;

          document.body.appendChild(app.view);

          let graphics = new PIXI.Graphics();
          graphics.lineStyle(0);
          const style = new PIXI.TextStyle({
              fontFamily: 'Arial',
              fontSize: 8,
              stroke: '#4a1850'
          });
          let nodes = osmtogeojson(xml.responseXML);

          nodes.features.forEach(node => {
            //console.log("node " + node.geometry.type);
            //console.log(node);
            if( node.geometry.type == "Point" && node.properties['addr:city'] == 'Saco' && house ){
              let point = mapSys.get_map(node.geometry.coordinates[0], node.geometry.coordinates[1]);

              graphics.beginFill(0x650a5a, 1);
              graphics.drawRect(point.x, point.y, 2, 2);
              graphics.endFill();

              let basicText = new PIXI.Text(node.properties['addr:housenumber'], style);
              basicText.x = point.x + 2;
              basicText.y = point.y - 2;

              app.stage.addChild(basicText);
            } if( node.geometry.type == "LineString" && node.properties['waterway'] != 'stream' 
                && node.properties['waterway'] != 'river' ) {

                  //road
                  console.log(" size " + node.geometry.coordinates.length);
                  if( node.geometry.coordinates.length >= sizeRoad) {
                    roadPs = []
                    node.geometry.coordinates.forEach(p => {
                      let point = mapSys.get_map(p[0], p[1]);
                      roadPs.push(point);
                      
                    });
                    roads.push( new Road(roadPs, true, 1, ROAD_SIZE));
                  }
                  

                  // let tempP = mapSys.get_map(node.geometry.coordinates[0][0], node.geometry.coordinates[0][1]);
                  // let roadF = tempP;

                  // graphics.lineStyle(1, '#000000');
                  // graphics.moveTo(tempP.x, tempP.y);
                  // node.geometry.coordinates.forEach(p => {
                  //   let point = mapSys.get_map(p[0], p[1]);
                  //   console.log(point)
                  //   graphics.lineTo(point.x, point.y);
                  // });

            } else {
              if(water){
                console.log(" water on");
                if(node.properties['waterway'] == 'stream'  || node.properties['waterway'] == 'river'){

                  let tempP = mapSys.get_map(node.geometry.coordinates[0][0], node.geometry.coordinates[0][1]);
                  graphics.lineStyle(2, '#0000FF');
                  graphics.moveTo(tempP.x, tempP.y);
                
                  node.geometry.coordinates.forEach(p => {
                    let point = mapSys.get_map(p[0], p[1]);
                    graphics.lineTo(point.x, point.y);
                  });
                } else {
                  //console.log(node);
                }
              }

            }
          });

          console.log(" intersection below");
          let inters = [];

          // for (let i = 0; i < roads.length; i++) {
          //     for (let l = i + 1; l < roads.length; l++) {
          //         let val = FindIntersection( roads[i], roads[l]);
          //         console.log(" found intersections below ");
          //         console.log(val);
          //         for (let m = 0; m < val.length; m++) {
          //             let temp = new Intersection(val[m][0], val[m][1], Math.floor(ROAD_SIZE/2))
          //             temp.set_lights( false);
          //             inters.push(temp);
          //         }
          //         // let temp = new Intersection(val[0][0], val[0][1], Math.floor(ROAD_SIZE/2))
          //         // temp.set_lights( false);
          //         // inters.push(temp);
          //         // roads[i].accept_inter(temp);
          //         // roads[l].accept_inter(temp);
          //         // temp.accept_road( roads[i] );
          //         // temp.accept_road( roads[l] );
          //     }
          // }

          roads.forEach(road => {
            road.draw(graphics);
          });

          app.stage.addChild(graphics);

          const thing = new PIXI.Graphics();

          app.stage.eventMode = 'static';
          app.stage.hitArea = app.screen;
          app.stage.addEventListener('click', (e) =>
          {
              running = !running; 
              let m_x = e.client.x;
              let m_y = e.client.y;
              for (let l = 0; l < inters.length; l++) {
                  if( inters[l].check_in_bounds(m_x, m_y)){
                      $("#log").prepend(" in intersection <br> " );
                  }
              }
              $("#log").prepend(" x = " + m_x + " y  = "  + m_y + " <br> " );
          });

          app.stage.addChild(thing);
          thing.x = 0;
          thing.y = 0;

          for (let i = 0; i < roads.length; i++) {
              startPs = startPs.concat( roads[i].get_start_p());
          }
          console.log(" making car");
          makeCar();

          roads.forEach(road => {
              road.check_cars_end();
          });

          // console.log("interseciton at 160, 90");
          inters.forEach(inter => {
              inter.draw_background(graphics);
          })

          let elapsed = 0.0;
          app.ticker.add((delta) =>
          {
              elapsed += delta;

              if( running){
                  thing.clear();
                  // inters.forEach(inter => {
                  //     inter.update_time(delta);
                  //     inter.draw( thing );
                  // });
              }
              roads.forEach(road => {
                console.log(" drawing ");
                  road.draw_cars( thing, running );
              });

              // if( current_car < MAX_CARS && car_pause > pause_car){
              //     makeCar();
              //     current_car++;
              //     car_pause = 0;
              // } else {
              //     car_pause++;
              // }

          });
        }

        function makeCar(){
            let car = new Car( 20, 20, CAR_SIZE );
            cars.push(car);

            let ran = checkStartP();
            //let ran = Math.floor(Math.random() * startPs.length);
            for (let l = 0; l < roads.length; l++) {
                if(roads[l].has_start_p(startPs[ran])){
                    roads[l].accept_car_lane(car, startPs[ran]);

                    let end_i = 0;
                    if( l < roads.length - 1 ){
                        end_i = l + 1;
                    } 

                    let endPs = roads[end_i].get_end_p();

                    endPs.push(roads[l].get_given_end(startPs[ran]));

                    let ran_2 = Math.floor(Math.random() * endPs.length);
                    car.set_end(endPs[ran_2].x, endPs[ran_2].y );
                }
                
            }
        }

        function checkStartP(){
            let found = false;
            let ran = Math.floor(Math.random() * startPs.length);
            while(!found){
                for (let l = 0; l < roads.length; l++) {
                    if(roads[l].has_start_p(startPs[ran])){
                        if(!roads[l].check_lane_start(startPs[ran])){
                            found = true;
                        } 
                    }
                }
                if( ran < startPs.length - 1){
                    ran++;
                } else {
                    ran = 0;
                }
            }
            return ran; 
        }
      
        window.onload = (event) => {
          $('#water').change(function() {
              if (this.checked) {
                console.log(" water");
                water = true;
              } else {
                console.log(" no water");
                water = false;
              }
          });

          $('#house').change(function() {
              // this will contain a reference to the checkbox   
              if (this.checked) {
                console.log(" house");
                house = true; 
              } else {
                console.log(" no house");
                house = false; 
              }
          });

          $('#size').change(function() {
              // this will contain a reference to the checkbox   
              console.log( this.value );
              sizeRoad =  this.value;
          });

          size

          $('#maps').on('change', function() {
            if( this.value != -1){
              console.log( this.value );
              //app.clear();
              cars = [];
              startPs = [];
              roads = [];

              genMap( this.value );
            }
          });

        };


      
    </script>
    <div id="log">

    </div>
    <div id="controls">
      <input type="checkbox" id="water" name="water" value="water">
      <label for="water"> Turn on Water</label><br>
      <input type="checkbox" id="house" name="house" value="house">
      <label for="house"> Turn on House</label><br>
      <input type="input" id="size" name="size" value="0">
      <label for="house"> Size of Roads</label><br>

      <select name="maps" id="maps" title="maps">
        <option value="-1">-?-</option>
        <option value="0">Map 1</option>
        <option value="1">Map 2</option>
        <option value="2">Map 3</option>
        <option value="3">Map 4</option>
        <option value="4">Map 5</option>
      </select>

    </div>

  </body>
</html>