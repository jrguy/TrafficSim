<html>
  <head>
    <script src='osmtogeojson.js'></script>
    <!-- <script src="https://pixijs.download/release/pixi.min.js"></script> -->
    <script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
    <script src="mapReader.js"></script>
    <script src="car.js"></script>
    <script src="curveRoads.js"></script>
    <script src="inter.js"></script>
  </head>
  <body>
    <script>
        const WIDTH = 640; 
        const HEIGHT = 380;
        const HOR_ROAD = 1; 
        const VER_ROAD = 1;
        const CARS = 4;
        const MAX_CARS = 10;
        const ROAD_SIZE = 20;
        const CAR_SIZE = 8;

        let cars = [];
        let startPs = [];
        let roads = [];
        let water = false;
        let house = false; 


        let file = "maps/northStreet.xml";

        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                myFunction(this);
            }
        };
        xhttp.open("GET", "maps/mapleStreet.xml", true);
        xhttp.send();

        function myFunction(xml) {
          let bounds = [];
          for (let i = 0; i < 4; i++) {
            bounds.push(xml.responseXML.all[1].attributes[i].nodeValue);
          }

          let mapSys = new coords(bounds);
          let width = mapSys.get_width();
          let height = mapSys.get_height();
          const app = new PIXI.Application({ background: '#87CEFA', width: width, height: height });

          let roadPs = [];
          let running = true; 
          let current_car = 1; 
          let pause_car = 40;
          let car_pause = 0;

          document.body.appendChild(app.view);

          let graphics = new PIXI.Graphics();
          graphics.lineStyle(0);
          const style = new PIXI.TextStyle({
              fontFamily: 'Arial',
              fontSize: 8,
              stroke: '#4a1850'
          });
          let nodes = osmtogeojson(xml.responseXML);

          nodes.features.forEach(node => {
            //console.log("node " + node.geometry.type);
            //console.log(node);
            if( node.geometry.type == "Point" && node.properties['addr:city'] == 'Saco' && house ){
              let point = mapSys.get_map(node.geometry.coordinates[0], node.geometry.coordinates[1]);

              graphics.beginFill(0x650a5a, 1);
              graphics.drawRect(point.x, point.y, 2, 2);
              graphics.endFill();

              let basicText = new PIXI.Text(node.properties['addr:housenumber'], style);
              basicText.x = point.x + 2;
              basicText.y = point.y - 2;

              app.stage.addChild(basicText);
            } if( node.geometry.type == "LineString" && node.properties['waterway'] != 'stream' 
                && node.properties['waterway'] != 'river' ) {

                  //road
                  console.log(" size " + node.geometry.coordinates.length);
                  roadPs = []
                  node.geometry.coordinates.forEach(p => {
                    let point = mapSys.get_map(p[0], p[1]);
                    roadPs.push(point);
                    
                  });
                  roads.push( new Road(roadPs, true, 1, ROAD_SIZE));
                  

                  // let tempP = mapSys.get_map(node.geometry.coordinates[0][0], node.geometry.coordinates[0][1]);
                  // let roadF = tempP;

                  // graphics.lineStyle(1, '#000000');
                  // graphics.moveTo(tempP.x, tempP.y);
                  // node.geometry.coordinates.forEach(p => {
                  //   let point = mapSys.get_map(p[0], p[1]);
                  //   console.log(point)
                  //   graphics.lineTo(point.x, point.y);
                  // });

            } else {
              if(water){
                if(node.properties['waterway'] == 'stream'  || node.properties['waterway'] == 'river'){

                  let tempP = mapSys.get_map(node.geometry.coordinates[0][0], node.geometry.coordinates[0][1]);
                  graphics.lineStyle(2, '#0000FF');
                  graphics.moveTo(tempP.x, tempP.y);
                
                  node.geometry.coordinates.forEach(p => {
                    let point = mapSys.get_map(p[0], p[1]);
                    graphics.lineTo(point.x, point.y);
                  });
                } else {
                  //console.log(node);
                }
              }

            }
          });

          roads.forEach(road => {
            road.draw(graphics);
          });

          app.stage.addChild(graphics);

          const thing = new PIXI.Graphics();

          app.stage.addChild(thing);
          thing.x = 0;
          thing.y = 0;

          for (let i = 0; i < roads.length; i++) {
              startPs = startPs.concat( roads[i].get_start_p());
          }
          console.log(" making car");
          makeCar();

          roads.forEach(road => {
              road.check_cars_end();
          });

          let elapsed = 0.0;
          app.ticker.add((delta) =>
          {
              elapsed += delta;

              if( running){
                  thing.clear();
                  // inters.forEach(inter => {
                  //     inter.update_time(delta);
                  //     inter.draw( thing );
                  // });
              }
              roads.forEach(road => {
                console.log(" drawing ");
                  road.draw_cars( thing, running );
              });

              // if( current_car < MAX_CARS && car_pause > pause_car){
              //     makeCar();
              //     current_car++;
              //     car_pause = 0;
              // } else {
              //     car_pause++;
              // }

          });
        }



        function makeCar(){
            let car = new Car( 20, 20, CAR_SIZE );
            cars.push(car);

            let ran = checkStartP();
            //let ran = Math.floor(Math.random() * startPs.length);
            for (let l = 0; l < roads.length; l++) {
                if(roads[l].has_start_p(startPs[ran])){
                    roads[l].accept_car_lane(car, startPs[ran]);

                    let end_i = 0;
                    if( l < roads.length - 1 ){
                        end_i = l + 1;
                    } 

                    let endPs = roads[end_i].get_end_p();

                    endPs.push(roads[l].get_given_end(startPs[ran]));

                    let ran_2 = Math.floor(Math.random() * endPs.length);
                    car.set_end(endPs[ran_2].x, endPs[ran_2].y );
                }
                
            }
        }

        function checkStartP(){
            let found = false;
            let ran = Math.floor(Math.random() * startPs.length);
            while(!found){
                for (let l = 0; l < roads.length; l++) {
                    if(roads[l].has_start_p(startPs[ran])){
                        if(!roads[l].check_lane_start(startPs[ran])){
                            found = true;
                        } 
                    }
                }
                if( ran < startPs.length - 1){
                    ran++;
                } else {
                    ran = 0;
                }
            }
            return ran; 
        }
      



      
    </script>
  </body>
</html>